# C语言学习错题本

> 2025.9.24 学完了翁恺老师的C语言入门课程 做了小题练练手

## 1. 函数指针概念理解错误

### 题目

关于函数指针，以下说法错误的是：

- A. 通过函数指针调用函数的时候不能传递参数  
- B. 通过函数指针可以调用一个函数  
- C. 函数指针可以作为参数传给一个函数  
- D. 函数的名字就是函数的指针值，可以赋给函数指针变量  

**正确答案：A**  
**我的答案：D**

### 解析

- **A选项错误**：通过函数指针调用函数时可以传递参数，与直接调用函数的方式相同
- **D选项正确**：函数名确实就是函数的地址，可以赋值给函数指针变量
- 函数指针的使用方式：`(*func_ptr)(arg1, arg2)` 或 `func_ptr(arg1, arg2)`

### 知识点

- 函数指针的声明和使用
- 函数名作为地址的概念
- 函数指针作为参数传递（回调函数）

---

## 2. 数组名与指针的区别理解错误

### 题目

若定义 `int k, a[10], *p=a;` 那么下面表达式不能被编译的是______。

- A. `a++;`
- B. `a[0] = k;`
- C. `p++;`
- D. `p[0] = k;`

**正确答案：A**  
**我的答案：D**

### 解析

- **A选项错误**：数组名`a`是常量指针，不能进行自增操作
- **D选项正确**：`p[0]`等价于`*p`，是合法的赋值操作
- `p`是指针变量，可以进行`p++`操作
- `a[0]`是数组元素，可以赋值

### 知识点

- 数组名是常量指针，不能修改
- 指针变量可以进行算术运算
- 数组下标访问的本质是指针运算

---

## 3. 带参宏定义展开错误

### 题目

下列程序段的输出是______。

```c
#define DF(a,b) (a+2*b)
int s=5;
int k= DF(s+1,s-3);
printf("%d",k);
```

**正确答案：13**  
**我的答案：10**

### 解析

宏展开过程：

```c
DF(s+1,s-3) → (s+1+2*s-3)
→ 5+1+2*5-3
→ 6+10-3 = 13
```

### 知识点

- 宏定义是简单的文本替换
- 替换时要注意运算符优先级问题
- 为避免优先级问题，宏定义中参数应加括号：`#define DF(a,b) ((a)+2*(b))`

---

## 4. 复杂指针运算理解错误

### 题目

与 `while( *s++ = *t++ );` 等价的程序段是

A. 

```c
do {
    *s++ = *t++;
} while ( *t );
```

B. 

```c
while ( *t )
    *s++ = *t++;
```

C. 

```c
while ( *s )
    *s++ = *t++;
```

D. 

```c
do {
    *s = *t++;
} while ( *s++ );
```

**正确答案：D**  
**我的答案：C**

### 解析

- 原语句逻辑：先赋值，再指针自增，最后判断赋值结果
- **D选项正确**：`*s = *t++` 完成赋值和t自增，`*s++` 判断赋值结果并完成s自增
- **C选项错误**：判断条件是`*s`而不是赋值结果，逻辑完全错误

### 知识点

- 赋值表达式的值就是所赋的值
- 后置++的执行时机
- 字符串复制必须包含结束符的复制

---

## 5. 函数返回指针的安全性判断

### 题目

以下哪个函数是不正确的（与能否被编译无关）？

A. 

```c
int* f(int *p) {
    int i;
    return &i;
}
```

B. 

```c
int* f(int *p) {
    return p;
}
```

C. 

```c
int* f(int *p) {
    return NULL;
}
```

D. 

```c
int* f(int *p) {
    return (int*)malloc(sizeof(int));
}
```

**正确答案：A**

### 解析

- **A选项不正确**：返回局部变量的地址，函数返回后该内存无效
- 其他选项都是安全的指针返回方式

### 知识点

- 不能返回局部变量的地址
- 可以返回参数指针、全局变量、静态变量或动态分配的内存

---

## 6. 复杂程序输出分析（未作答）

### 题目

以下代码段的输出是：

```c
int x, y, z, w;
void p(int *y, int x) {
    static int w;
    *y++; x++; w = x+*-y;
    printf("%d#%d#%d#%d#",x,*y,z,w);
}
int main(void) {
    int x, y, z, w;
    x=y=z=w=1;
    do{
        static int x;
        p(&x, y);
        printf("%d#%d#%d#%d#",x,y,z,w);
    } while(0);
    return 0;
}
```

**正确答案：2#0#0#2#0#1#1#1#**

### 解析

关键点分析：

1. 静态局部变量`static int x`自动初始化为0
2. `*y++`先取`*y`再指针自增，但`*y`是静态变量x的值为0
3. 全局变量z默认初始化为0
4. 函数内w是静态变量，独立于全局w

### 知识点

- 静态局部变量的初始化
- 指针运算的优先级
- 变量作用域和生命周期
- 全局变量的默认初始化

---

## 7. 字符串插入排序（未作答）

### 题目

以下代码段的输出是：

```c
char a[20]="cehiknqtw";
char *s="fbla";
int i,j;
for(p=s; *p; p++) {
    j=0;
    while (*p>=a[j] && a[j]!='\0') j++;
    for(i=strlen(a); i>=j; i--) a[i+1] = a[i];
    a[j]=*p;
}
printf("%s", a);
```

**正确答案：abcefhiklnqtw**

### 解析

算法分析：

1. 将字符串s中的每个字符按顺序插入到已排序的数组a中
2. 插入过程保持a数组有序
3. 最终得到合并后的有序字符串

### 知识点

- 字符串操作
- 插入排序算法
- 字符比较和数组移动

---

## 8. 宏定义嵌套展开

### 题目

根据下面的定义，`F0(3+4)`的输出结果是______

```c
#define F1(var) printf("var=%d", var)
#define F0(var) F1(var * var)
```

**正确答案：var=19**

### 解析

宏展开过程：

```c
F0(3+4) → F1(3+4 * 3+4)
→ printf("var=%d", 3+4*3+4)
→ 3+12+4 = 19
```

### 知识点

- 宏定义的嵌套展开
- 运算符优先级在宏展开中的影响
- 宏参数替换是纯粹的文本替换

---

## 9. 命令行参数处理

### 题目

程序T1的代码如下，则运行`T1 abc bcd cde aed`的输出结果是______。

```c
int main(int argc, char** argv) {
    while(*argv++!='a');
    printf("%s", *argv);
    return 0;
}
```

**正确答案：bcd**

### 解析

执行过程：

1. `argv`指针遍历参数数组
2. 寻找第一个以'a'开头的字符串参数
3. 找到"aed"后，`argv++`指向下一个参数（已越界，实际行为未定义）
4. 但根据题意，应该是找到"abc"后继续移动到"bcd"

### 知识点

- 命令行参数处理
- 指针数组的遍历
- 字符串比较

---

## 总结

### 主要薄弱环节

1. **指针运算和优先级**：特别是后置++与解引用操作的结合
2. **宏定义展开**：对纯文本替换的理解不够深入
3. **复杂表达式求值**：需要加强运算符优先级的掌握
4. **程序逻辑分析**：多语句组合时的执行顺序判断

### 学习建议

1. 多做指针运算的练习题
2. 手动展开宏定义来加深理解
3. 使用调试器单步跟踪复杂表达式
4. 多分析经典算法和代码片段


