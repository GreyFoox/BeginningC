#include <stdio.h>
#include <string.h>
#include <stdbool.h>

int main() {
    int t;
    scanf("%d", &t);
    for (int i = 0; i < t; i++) {
        int n;
        scanf("%d", &n);
        char str[51];  // 因n≤50，足够存储字符串
        scanf("%s", str);
        
        int b_count = 0;  // 优化：变量名更清晰，明确表示B的数量
        for (int j = 0; j < n; j++) {  // 优化：循环变量名从i改为j，避免与外层循环冲突
            if (str[j] == 'B') {
                b_count++;
            }
        } 
        
        // 拆分复杂条件，提高可读性
        bool cond1 = (str[n - 1] == 'A' && (str[0] == 'A' || str[n - 2] == 'A'));
        bool cond2 = (str[0] == 'A' && str[n - 2] == 'A' && str[n - 1] == 'B' && b_count == 1);
        
        if (cond1 || cond2) {
            printf("Alice\n");
        } else {
            printf("Bob\n");
        }
    }
    return 0;
}

//考场上没做出来，其实这是我第一次见到博弈论，刚刚看了题解，我的总结如下：
/*
我们代入Alice视角 
	最小1	次大	最大 
	0		0		0		啥都没有，必输 
	0		0		1		我们有最大，没1，出最大被1夺，不出被其它夺，怎么出都被夺，必输 
	0		1		0		我们有次大，但是无最大，我们出次大，对面出最大，必输 
	0		1		1		我们有次大和最大，但没1，我们出次大，必赢 
	1		0		0		我们只有1，对面出次大，必输 
	1		0		1		我们有1和最大，出最大，必赢 
	1		1		0		我们有1和次大，出次大会被夺，不出还是被夺，必输。       但是如果对方只有最大，则无法防我们的1，必赢 
	1		1		1		我们三都有，必赢 
我们在(0, 1, 1)(1, 0, 1)(1, 1, 1)的时候会赢，可以如下总结
我们有最大且有其它两张中任意一张的时候会赢，或者我们有次大，1但是对面只有最大的时候会赢 
*/
    
