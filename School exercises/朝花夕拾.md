### 朝花夕拾



##### 输出每个月的天数

两个数组的内容高度相似 且需要打印 ->  采用一个数组 遍历时 有条件的打印不同  

`return (is_leap && month == 2) ? 29 : days[month];`



##### 逆序数

```c
	int result = 0;
	while(number) {
		int i = number % 10;
		result = result * 10 + i;
		number /= 10; 
	}
	return result;
}  
```

> 比如123变为321 即3  * 10^3 + 2 * 10^2  + 1*10
>
> 取3 2 1的过程中 数字每次“缩短” *10也相应“缩短”



#####  近似求PI

double左值 的 右值 应也是 double

```c
double sum = 1.0; 
    double term = 1.0; 
    int i = 1;         

term = term * i / (2 * i + 1);
```



##### 英文字母替换加密

```c
	 // 循环读取直到换行符，避免冗余的EOF判断（专注一行处理）
    while ((c = getchar()) != '\n') {
        // 处理小写字母：后移1位 + 转大写（符合题目加密规则）
        if (c >= 'a' && c <= 'z') {  
            // 边界说明：<= 'z'中的'='不可省略，否则会漏掉z→A的转换
            int offset = (c - 'a' + 1) % 26;  // 模26处理循环，比硬编码更可靠
            putchar('A' + offset);  // 性能优化：putchar比printf少格式解析开销
        }
        // 处理大写字母：后移1位 + 转小写
    	putchar('\n');  // 补充换行，保持输入输出格式一致
```

`循环 ` 可以考虑取模

> `getchar()` 函数使用**行缓冲输入**：
>
> - 用户输入的字符先存储在**缓冲区**
> - 只有当按下 **回车键** (`\n`) 时，整个缓冲区的内容才会一次性提交给程序
> - 程序开始逐个读取并处理字符



##### **计算火车运行时间**

```c
start_m = (start / 100) * 60 + (start % 100); //截取时和分 并进行转化
end_m = (end / 100) * 60 + (end % 100);
travel_m = end_m - start_m;
printf("%02d:%02d\n", travel_m / 60, travel_m % 60);
```

```
1201 1530
03:29
```

> **格式化字符串 `"%02d:%02d\n"`**
>
> - **`%02d`**：格式化说明符
>   - `%d` - 表示输出整数
>   - `0` - 表示用0填充空白
>   - `2` - 表示最小宽度为2位



##### 求组合数

```c
//记忆化递归
double fact(int n, double memo[]){
	memo[0] = 1;
	memo[1] = 1;
	if (memo[n] == -1) {
		memo[n] = n * fact(n - 1, memo);
		return memo[n];
	}
	else return memo[n];
}

int main(){
	int m;
	int n;
	scanf("%d %d", &m, &n);
	if (m > n) return 1;
	double memo[n + 1];
	for (int i = 0; i < n + 1; i++) {
		memo[i] = -1;
	}//数据初始化
	double result = fact(n, memo) / (fact(m, memo) * fact(n - m, memo));
	printf("result = %.0f\n", result);
	return 0; 
} 
```



##### 统计素数并求和

```c
bool isPrime(int n) {
    // 处理特殊情况
    if (n <= 1) return false;
    if (n == 2) return true;      // 2是质数
    if (n % 2 == 0) return false; // 排除其他偶数
    
    // 只在奇数中检查
    for (int i = 3; i <= n / i; i += 2) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```

> **核心原理**
>
> - **2是唯一的偶质数**
> - **其他所有质数都是奇数**
> - 因此只需要在奇数范围内进行质数判断



##### 使用函数输出一个整数的逆序数

```c
int reverse(int number) {
	int result = 0;
	while(number) {
		int i = number % 10;
		result = result * 10 + i;
		number /= 10; 
	}
	return result;
}
```

> **取尾、构建、去尾**
>
> - 取尾：`number % 10` 取最后一位
> - 构建：`result * 10 + i` 构建反转数
> - 去尾：`number / 10` 去掉已处理位

##### 矩阵运算

```c
int sum = 0;
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
		 	if(i == n-1 || j == n-1 || i + j == n-1) {
		 		//副对角线是从右上角到左下角，即元素位置满足 i + j = n - 1。
		 		// 跳过这些元素
			 } else{
			 	sum += arr[i][j];
			 }
		}	
	}
```



##### 统计大写辅音字母

```c
while((c = getchar())!= '\n') {
		if(c >= 'A' && c <= 'Z' && c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {
			sum++;
		}
	}
```

> 持续输入`while((c = getchar())!= '\n')` 



##### 查找指定字符

```c
#include <string.h>
char str[81];
fgets(str, 81, stdin);
```



##### 字符串替换

```c
for(int i = 0; i < strlen(s1); i++) {
		if(s1[i] >= 'A' && s1[i] <= 'Z') { // 修正条件判断
			int found = 0; // 标记是否已存在
			for(int j = 0; j < index; j++) { // 只需遍历到index位置
				if(s1[i] == s2[j]) {
					found = 1;
					break;
				}
			}
			if(!found) { // 如果没找到，则添加到s2
				s2[index] = s1[i];
				index++;
			}
		}
	}
```

> C里面没有`for-else` 如果需要使用类似，请使用标记变量



##### 删除重复字符

```c
//双指针去重
#include <stdio.h>
#include <string.h>

void removeDuplicates(char *str) {
    if (str == NULL) return;
    
    int len = strlen(str);
    if (len <= 1) return;
    
    int tail = 1; // 去重后字符串的末尾位置
    
    for (int i = 1; i < len; i++) {
        int j;
        // 检查当前字符是否在已处理部分出现过
        for (j = 0; j < tail; j++) {
            if (str[i] == str[j]) {
                break;
            }
        }
        
        // 如果没出现过，添加到结果中
        if (j == tail) {
            str[tail++] = str[i];
        }
    }
    
    str[tail] = '\0';
}
```

```c
//快速排序
#include <stdio.h>
void swap(int *a, int *b) {
	int tmp = *a;
	*a = *b;
	*b = tmp;
} 

void quickSort(int nums[], int left, int right) {
	int i = left;
	int j = right;
	int mid = left + (right - left) / 2;
	int p = nums[mid];
	while (i <= j) {
		while (nums[i] < p) i++;
		while (nums[j] > p) j--;
		if (i <= j) {
			swap(&nums[i], &nums[j]);
			i++, j--;
		}
	}
	if (left < j) quickSort(nums, left, j);
	if (right > i) quickSort(nums, i, right);
}
```



##### 查找书籍

```c
//结构体数组
#include <stdio.h>
#include <string.h>

struct Book {
    char name[31];
    double price;
};

int main() {
    int n;
    scanf("%d", &n);
    getchar(); 
    
    struct Book books[10]; 
    
    for(int i = 0; i < n; i++) {
        fgets(books[i].name, 31, stdin);
        books[i].name[strcspn(books[i].name, "\n")] = '\0';
        scanf("%lf", &books[i].price);
        getchar(); 
    }
```

##### 一帮一

```c++
#include <iostream>
#include <vector>
using namespace std;

// 定义学生结构体，包含性别和姓名
struct node {
    int a;        // 性别：0代表女生，1代表男生
    string s;     // 姓名
};

int main() {
    int n;
    cin >> n;      // 输入学生总数
    
    vector<node> stu;  // 使用动态数组存储学生信息
    
    // 输入每个学生的信息，按名次从高到低排列
    for(int i = 0; i < n; i++) {
        node temp;
        cin >> temp.a >> temp.s;  // 输入性别和姓名
        stu.push_back(temp);      // 添加到数组
    }
    
    // 初始化两个指针，都指向数组末尾（名次最低的学生）
    int j = n - 1, k = n - 1;
    
    // 只需要配对前一半的学生（名次较高的那一半）
    for(int i = 0; i < n/2; i++) {
        // 如果当前学生是男生
        if(stu[i].a == 1) {
            // 从后往前找到第一个女生（跳过所有男生）
            while(stu[j].a == stu[i].a) j--;
            // 输出配对结果：名次高的男生 + 名次低的女生
            cout << stu[i].s << " " << stu[j].s << endl;
            j--;  // 移动指针，该女生已被配对
        } 
        // 如果当前学生是女生
        else {
            // 从后往前找到第一个男生（跳过所有女生）
            while(stu[k].a == stu[i].a) k--;
            // 输出配对结果：名次高的女生 + 名次低的男生
            cout << stu[i].s << " " << stu[k].s << endl;
            k--;  // 移动指针，该男生已被配对
        }
    }
    
    return 0;
}
```

> 一道好题值得二次做

##### 大炮打蚊子

```c
#include <stdio.h>

int main() {
    int M, N;
    scanf("%d %d", &M, &N);
    getchar(); // 读取换行符，避免影响后续输入
    
    int health[M][N]; // 定义健康值矩阵
    
    // 读取网格数据并初始化健康值
    for (int i = 0; i < M; i++) {
        char line[N + 1]; // 字符串需要额外空间存储结束符'\0'
        scanf("%s", line);
        for (int j = 0; j < N; j++) {
            if (line[j] == '#') {
                health[i][j] = 2; // '#'表示有生命，初始健康值为2
            } else {
                health[i][j] = 0; // 其他字符表示无生命
            }
        }
    }
    
    int k; // 攻击次数
    scanf("%d", &k);
    
    // 四个方向：上、下、左、右
    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};
    
    // 处理每次攻击
    for (int i = 0; i < k; i++) {
        int x, y;
        scanf("%d %d", &x, &y);
        int count = 0; // 记录本次攻击消灭的生命数量
        
        // 攻击中心点
        if (health[x][y] > 0) {
            count++;
            health[x][y] = 0; // 直接消灭
        }
        
        // 攻击四个相邻位置
        for (int d = 0; d < 4; d++) {
            int nx = x + dx[d]; // 相邻位置的x坐标
            int ny = y + dy[d]; // 相邻位置的y坐标
            
            // 检查边界
            if (nx >= 0 && nx < M && ny >= 0 && ny < N) {
                if (health[nx][ny] > 0) {
                    health[nx][ny]--; // 健康值减1
                    if (health[nx][ny] == 0) {
                        count++; // 如果健康值降为0，计数增加
                    }
                }
            }
        }
        printf("%d\n", count); // 输出本次攻击的结果
    }
    
    return 0;
}
```

> 经典图论，看过就会做

#####  输出整数各位数字

```c
 char str[20];
 sprintf(str, "%ld", n);
```

> 这行代码使用 `sprintf` 函数将长整型数字 `n` 转换为字符串，并存储在字符数组 `str` 中。
>
> **详细解释**
>
> 1. **`sprintf` 函数**
>
> - **功能**：格式化输出到字符串
> - **语法**：`int sprintf(char *str, const char *format, ...)`
> - **作用**：将格式化的数据写入字符串
>
> **2. 参数分析**
>
> - `str`：目标字符数组，用于存储结果字符串
> - `"%ld"`：格式说明符，`%ld` 表示长整型 (long)
> - `n`：要转换的长整型变量
>
> **替代方案对比**
>
> **1. `snprintf` (更安全)**
>
> ```c
> char str[20];
> snprintf(str, sizeof(str), "%ld", n); // 防止缓冲区溢出
> ```

##### 打印九九口诀表

```c
 printf("%d*%d=%-4d", col, row, col * row);
```

> 格式说明符分解
>
> 1. **`%d` - 整数输出**
>
> - 输出十进制整数
> - 对应参数：`col`, `row`
>
>  2. **`%-4d` - 带格式的整数输出**
>
> - `-`：左对齐（默认是右对齐）
> - `4`：最小字段宽度为4个字符
> - `d`：十进制整数
> - 对应参数：`col * row`
>
> **输出效果示例**
>
> 假设 `col = 3`, `row = 4`：
>
> ```c
>printf("%d*%d=%-4d", 3, 4, 12);
> ```
> 
>  **左对齐 `%-4d`**
>
> ```c
>printf("%d*%d=%-4d", 3, 4, 12);  // 输出: "3*4=12  "
> printf("%d*%d=%-4d", 5, 6, 30);  // 输出: "5*6=30  "
>```
> 

>**右对齐 `%4d`（默认）**
> 
>```c
> printf("%d*%d=%4d", 3, 4, 12);   // 输出: "3*4=  12"
> printf("%d*%d=%4d", 5, 6, 30);   // 输出: "5*6=  30"
> ```

##### 将数组中的数逆序存放

```c
#include <stdio.h>

void swap(int *a, int *b) {
	int tmp = *a;
	*a = *b;
	*b = tmp;	
}

int* reverse(int nums[], int size) {
	int left = 0;
	int right = size - 1;
	while (left <= right) {
		swap(&nums[left++], &nums[right--]);
	}
	return nums;
}
```

> 逆序——简单双指针

